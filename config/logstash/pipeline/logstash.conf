input {
  # ========== HONEYPOTS DE RED ==========
  
  # 1. COWRIE (SSH/Telnet) - JSON
  file {
    path => "../../../data/cowrie/log/cowrie.json"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "cowrie"
    codec => json_lines
    tags => ["honeypot", "ssh", "telnet", "cowrie"]
    mode => "tail"
    stat_interval => 1
  }
  
  # 2. DIONAEA (Multi-protocol) - Texto
  file {
    path => "../../../data/dionaea/log/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "dionaea"
    tags => ["honeypot", "multi-protocol", "dionaea", "smb", "ftp", "mssql"]
    mode => "tail"
  }
  
  # 3. RDPy (RDP) - Texto
  file {
    path => "../../../data/rdpy/logs/rdpy.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "rdpy"
    tags => ["honeypot", "rdp", "remote-desktop", "rdpy"]
    mode => "tail"
  }
  
  # ========== HONEYPOTS WEB ==========
  
  # 4. DVWA Apache Access Logs
  file {
    path => "../../../data/dvwa/logs/access.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "dvwa_access"
    codec => "combinedapache"
    tags => ["honeypot", "web", "dvwa", "apache", "access"]
    mode => "tail"
  }
  
  # 5. DVWA Apache Error Logs
  file {
    path => "../../../data/dvwa/logs/error.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "dvwa_error"
    tags => ["honeypot", "web", "dvwa", "apache", "error"]
    mode => "tail"
  }
  
  # 6. DVWA Other Vhosts Access Logs
  file {
    path => "../../../data/dvwa/logs/other_vhosts_access.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "dvwa_other"
    tags => ["honeypot", "web", "dvwa", "apache", "vhost"]
    mode => "tail"
  }
  
  # ========== ENTRADAS ADICIONALES ==========
  
  # 7. TCP para logs en tiempo real (opcional)
  tcp {
    port => 5000
    codec => json_lines
    type => "tcp_json"
    tags => ["realtime", "json"]
  }
  
  # 8. UDP para syslog (opcional)
  udp {
    port => 514
    type => "syslog"
    tags => ["syslog"]
  }
}

filter {
  # ========== FILTROS POR TIPO DE HONEYPOT ==========
  
  # FILTRO COWRIE (JSON)
  if [type] == "cowrie" {
    mutate {
      add_field => {
        "honeypot_name" => "cowrie"
        "protocol" => "ssh/telnet"
        "category" => "network"
      }
    }
    
    # Parsear timestamp si existe
    if [timestamp] {
      date {
        match => [ "timestamp", "ISO8601" ]
        target => "@timestamp"
        timezone => "UTC"
      }
    }
    
    # Clasificar eventos Cowrie
    if [eventid] {
      mutate {
        add_field => { "event_type" => "%{eventid}" }
      }
      
      # Clasificar por severidad
      if [eventid] =~ /login/ {
        mutate {
          add_tag => ["authentication"]
          add_field => { "severity" => "medium" }
        }
      }
      
      if [eventid] =~ /command/ {
        mutate {
          add_tag => ["command_execution"]
          add_field => { "severity" => "high" }
        }
      }
    }
  }
  
  # FILTRO DIONAEA (TEXTO)
  if [type] == "dionaea" {
    mutate {
      add_field => {
        "honeypot_name" => "dionaea"
        "protocol" => "multi-protocol"
        "category" => "network"
      }
    }
    
    # Parsear múltiples formatos de Dionaea
    grok {
      match => {
        "message" => [
          # Formato 1: timestamp IP:port - message
          "%{TIMESTAMP_ISO8601:log_timestamp} %{IP:src_ip}:%{NUMBER:src_port} - %{GREEDYDATA:dionaea_event}",
          # Formato 2: timestamp message
          "%{TIMESTAMP_ISO8601:log_timestamp} %{GREEDYDATA:dionaea_event}",
          # Formato 3: solo mensaje
          "%{GREEDYDATA:dionaea_event}"
        ]
      }
      tag_on_failure => ["_dionaea_grok_failure"]
    }
    
    # Extraer protocolo del mensaje
    if [dionaea_event] =~ /SMB|smb/i {
      mutate {
        add_field => { "detected_protocol" => "smb" }
        add_tag => ["smb"]
      }
    }
    
    if [dionaea_event] =~ /FTP|ftp/i {
      mutate {
        add_field => { "detected_protocol" => "ftp" }
        add_tag => ["ftp"]
      }
    }
    
    if [dionaea_event] =~ /MSSQL|sql/i {
      mutate {
        add_field => { "detected_protocol" => "mssql" }
        add_tag => ["mssql"]
      }
    }
    
    # Parsear timestamp
    if [log_timestamp] {
      date {
        match => [ "log_timestamp", "ISO8601" ]
        target => "@timestamp"
        timezone => "UTC"
      }
      mutate {
        remove_field => [ "log_timestamp" ]
      }
    }
  }
  
  # FILTRO RDPy (TEXTO)
  if [type] == "rdpy" {
    mutate {
      add_field => {
        "honeypot_name" => "rdpy"
        "protocol" => "rdp"
        "category" => "network"
      }
    }
    
    # Parsear formato RDPy
    grok {
      match => {
        "message" => [
          # Formato 1: timestamp Connection from IP - User: X - Password: Y
          "%{TIMESTAMP_ISO8601:log_timestamp} Connection from %{IP:src_ip} - User: %{USERNAME:rdp_user} - Password: %{GREEDYDATA:rdp_password}",
          # Formato 2: timestamp Connection from IP - User: X
          "%{TIMESTAMP_ISO8601:log_timestamp} Connection from %{IP:src_ip} - User: %{USERNAME:rdp_user}",
          # Formato 3: Connection from IP - User: X
          "Connection from %{IP:src_ip} - User: %{USERNAME:rdp_user}"
        ]
      }
      tag_on_failure => ["_rdpy_grok_failure"]
    }
    
    # Parsear timestamp
    if [log_timestamp] {
      date {
        match => [ "log_timestamp", "ISO8601" ]
        target => "@timestamp"
        timezone => "UTC"
      }
      mutate {
        remove_field => [ "log_timestamp" ]
      }
    }
    
    # Clasificar
    mutate {
      add_tag => ["rdp", "remote_desktop"]
      add_field => { "severity" => "high" }
    }
  }
  
  # FILTRO DVWA ACCESS (Apache Combined)
  if [type] == "dvwa_access" {
    mutate {
      add_field => {
        "honeypot_name" => "dvwa"
        "protocol" => "http"
        "category" => "web"
      }
    }
    
    # Apache combined ya está parseado por el codec
    # Solo renombrar y añadir campos
    
    if [clientip] {
      mutate {
        rename => { "clientip" => "src_ip" }
      }
    }
    
    # Parsear fecha Apache
    if [timestamp] {
      date {
        match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
        target => "@timestamp"
        timezone => "UTC"
      }
    }
    
    # Clasificar por código de respuesta
    if [response] {
      mutate {
        add_field => { "http_response" => "%{response}" }
      }
      
      # Errores 4xx/5xx
      if [response] =~ /^4\d\d/ {
        mutate {
          add_tag => ["client_error"]
          add_field => { "severity" => "low" }
        }
      }
      
      if [response] =~ /^5\d\d/ {
        mutate {
          add_tag => ["server_error"]
          add_field => { "severity" => "medium" }
        }
      }
      
      # Éxitos
      if [response] =~ /^2\d\d/ {
        mutate {
          add_tag => ["success"]
          add_field => { "severity" => "info" }
        }
      }
    }
    
    # Detectar ataques comunes
    if [request] {
      # SQL Injection
      if [request] =~ /union.*select|select.*from|'.*or.*'|sleep\(|benchmark\(/i {
        mutate {
          add_tag => ["sql_injection"]
          add_field => { "attack_type" => "sql_injection", "severity" => "critical" }
        }
      }
      
      # Path Traversal
      if [request] =~ /\.\.\/|\.\.\\|etc\/passwd|win\.ini/i {
        mutate {
          add_tag => ["path_traversal"]
          add_field => { "attack_type" => "path_traversal", "severity" => "high" }
        }
      }
      
      # XSS
      if [request] =~ /<script|javascript:|onerror=|onload=/i {
        mutate {
          add_tag => ["xss"]
          add_field => { "attack_type" => "xss", "severity" => "high" }
        }
      }
    }
  }
  
  # FILTRO DVWA ERROR
  if [type] == "dvwa_error" {
    mutate {
      add_field => {
        "honeypot_name" => "dvwa"
        "log_type" => "error"
        "category" => "web"
        "severity" => "medium"
      }
      add_tag => ["apache_error"]
    }
    
    # Parsear errores comunes de Apache
    grok {
      match => {
        "message" => [
          # PHP errors
          "\[%{WORD:error_level}\] %{GREEDYDATA:error_message}",
          # Apache errors
          "\[%{WORD:module}:%{LOGLEVEL:loglevel}\] %{GREEDYDATA:error_message}",
          # Generic
          "%{GREEDYDATA:error_message}"
        ]
      }
    }
  }
  
  # FILTRO DVWA OTHER VHOSTS
  if [type] == "dvwa_other" {
    mutate {
      add_field => {
        "honeypot_name" => "dvwa"
        "log_type" => "vhost_access"
        "category" => "web"
      }
    }
    
    # Intentar parsear como Apache
    grok {
      match => { "message" => "%{COMBINEDAPACHELOG}" }
    }
    
    if [timestamp] {
      date {
        match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
        target => "@timestamp"
        timezone => "UTC"
      }
    }
    
    if [clientip] {
      mutate {
        rename => { "clientip" => "src_ip" }
      }
    }
  }
  
  # ========== FILTROS COMUNES A TODOS ==========
  
  # Geolocalización
  if [src_ip] {
    geoip {
      source => "src_ip"
      target => "geo"
      database => "/usr/share/logstash/vendor/bundle/jruby/2.6.0/gems/logstash-filter-geoip-7.2.9-java/vendor/GeoLite2-City.mmdb"
      fields => ["country_name", "city_name", "location", "continent_code", "country_code2", "country_code3"]
    }
    
    # Identificar IPs privadas
    cidr {
      address => [ "%{src_ip}" ]
      network => [ "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "127.0.0.0/8" ]
      add_field => { "ip_type" => "private" }
    }
    
    if ![ip_type] {
      mutate {
        add_field => { "ip_type" => "public" }
      }
    }
  }
  
  # User Agent parsing (para web)
  if [agent] or [http_user_agent] {
    useragent {
      source => "[agent]" ? "[agent]" : "[http_user_agent]"
      target => "user_agent"
      prefix => "ua_"
    }
  }
  
  # Añadir timestamp de procesamiento
  ruby {
    code => "event.set('processed_at', Time.now.utc.iso8601)"
  }
  
  # Añadir campo de entorno
  mutate {
    add_field => {
      "environment" => "honeypot"
      "data_source" => "logstash"
    }
  }
  
  # Limpiar campos temporales
  mutate {
    remove_field => [ "headers", "host", "version", "log_timestamp" ]
  }
}

output {
  # ========== SALIDA A ELASTICSEARCH ==========
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    
    # Índice por tipo y fecha
    if [type] {
      index => "honeypot-%{type}-%{+YYYY.MM.dd}"
    } else {
      index => "honeypot-logs-%{+YYYY.MM.dd}"
    }
    
    # Template para mapeo
    template => "/usr/share/logstash/pipeline/honeypot-template.json"
    template_name => "honeypot"
    template_overwrite => true
    
    # Configuración de resiliencia
    retry_initial_interval => 2
    retry_max_interval => 64
    retry_on_conflict => 3
    flush_size => 500
    idle_flush_time => 5
  }
  
  # ========== SALIDA DE DEBUG (OPCIONAL) ==========
  # stdout {
  #   codec => rubydebug {
  #     metadata => true
  #   }
  # }
  
  # ========== SALIDA A ARCHIVO PARA BACKUP ==========
  file {
    path => "/usr/share/logstash/data/processed-logs/%{type}-%{+YYYY-MM-dd}.log"
    codec => line { 
      format => "%{@timestamp} [%{type}] %{src_ip} -> %{message}" 
    }
    flush_interval => 5
  }
}
